<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TSx.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://xKDR.github.io/TSx.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TSx.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/xKDR/TSx.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TSx"><a class="docs-heading-anchor" href="#TSx">TSx</a><a id="TSx-1"></a><a class="docs-heading-anchor-permalink" href="#TSx" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/xKDR/TSx.jl">TSx</a>.</p><ul><li><a href="#TSx.TS"><code>TSx.TS</code></a></li><li><a href="#Base.getindex-Tuple{TS, Int64}"><code>Base.getindex</code></a></li><li><a href="#Base.join-Tuple{TS, TS}"><code>Base.join</code></a></li><li><a href="#Base.names-Tuple{TS}"><code>Base.names</code></a></li><li><a href="#Base.size-Tuple{TS}"><code>Base.size</code></a></li><li><a href="#Base.vcat-Tuple{Vararg{TS}}"><code>Base.vcat</code></a></li><li><a href="#RecipesBase.apply_recipe"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#TSx.apply-Union{Tuple{V}, Tuple{T}, Tuple{TS, Union{Type{T}, T}, V}, Tuple{TS, Union{Type{T}, T}, V, Function}} where {T&lt;:Union{Dates.DatePeriod, Dates.TimePeriod}, V&lt;:Function}"><code>TSx.apply</code></a></li><li><a href="#TSx.index-Tuple{TS}"><code>TSx.index</code></a></li><li><a href="#TSx.lag"><code>TSx.lag</code></a></li><li><a href="#TSx.lead"><code>TSx.lead</code></a></li><li><a href="#TSx.log"><code>TSx.log</code></a></li><li><a href="#TSx.ncol-Tuple{TS}"><code>TSx.ncol</code></a></li><li><a href="#TSx.nrow-Tuple{TS}"><code>TSx.nrow</code></a></li><li><a href="#TSx.rollapply-Tuple{Function, TS, Any, Int64}"><code>TSx.rollapply</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TSx.TS" href="#TSx.TS"><code>TSx.TS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TS
  coredata :: DataFrame
end</code></pre><p><code>::TS</code> - A type to hold ordered data with an index.</p><p>A TS object is essentially a <code>DataFrame</code> with a specific column marked as an index. The input <code>DataFrame</code> is sorted during construction and is stored under the property <code>coredata</code>. The index is stored in the <code>Index</code> column of <code>coredata</code>.</p><p>Permitted data inputs to the constructors are <code>DataFrame</code>, <code>Vector</code>, and 2-dimensional <code>Array</code>. If an index is already not present in the constructor then a sequential integer index is created automatically.</p><p><code>TS(coredata::DataFrame)</code>: Here, the constructor looks for a column named <code>Index</code> in <code>coredata</code> as the index column, if this is not found then the first column of <code>coredata</code> is made the index by default. If <code>coredata</code> only has a single column then a new sequential index is generated.</p><p>Since <code>TS.coredata</code> is a DataFrame it can be operated upon independently using methods provided by the DataFrames package (ex. <code>transform</code>, <code>combine</code>, etc.).</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">TS(coredata::DataFrame, index::Union{String, Symbol, Int})
TS(coredata::DataFrame, index::AbstractVector{T}) where {T&lt;:Union{Int, TimeType}}
TS(coredata::DataFrame)
TS(coredata::DataFrame, index::UnitRange{Int})
TS(coredata::AbstractVector{T}, index::AbstractVector{V}) where {T, V}
TS(coredata::AbstractVector{T}) where {T}
TS(coredata::AbstractArray{T,2}) where {T}
TS(coredata::AbstractArray{T,2}, index::AbstractVector{V}) where {T, V}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random;
julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; df = DataFrame(x1 = random(10))

julia&gt; ts = TS(df)   # generates index
(10 x 1) TS with Int64 Index

 Index  x1        
 Int64  Float64   
──────────────────
     1  0.768448
     2  0.940515
     3  0.673959
     4  0.395453
     5  0.313244
     6  0.662555
     7  0.586022
     8  0.0521332
     9  0.26864
    10  0.108871

# ts.coredata is a DataFrame
julia&gt; combine(ts.coredata, :x1 =&gt; Statistics.mean, DataFrames.nrow)
1×2 DataFrame
 Row │ x1_mean  nrow
     │ Float64  Int64
─────┼────────────────
   1 │ 0.49898    418

julia&gt; df = DataFrame(ind = [1, 2, 3], x1 = random(3))
3×2 DataFrame
 Row │ ind    x1       
     │ Int64  Float64  
─────┼─────────────────
   1 │     1  0.768448
   2 │     2  0.940515
   3 │     3  0.673959

julia&gt; ts = TS(df, 1)        # the first column is index
(3 x 1) TS with Int64 Index

 Index  x1       
 Int64  Float64  
─────────────────
     1  0.768448
     2  0.940515
     3  0.673959

julia&gt; df = DataFrame(x1 = random(3), x2 = random(3), Index = [1, 2, 3]);
3×3 DataFrame
 Row │ x1        x2        Index 
     │ Float64   Float64   Int64 
─────┼───────────────────────────
   1 │ 0.768448  0.768448      1
   2 │ 0.940515  0.940515      2
   3 │ 0.673959  0.673959      3

julia&gt; ts = TS(df)   # uses existing `Index` column
(3 x 2) TS with Int64 Index

 Index  x1        x2       
 Int64  Float64   Float64  
───────────────────────────
     1  0.768448  0.768448
     2  0.940515  0.940515
     3  0.673959  0.673959

julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2017,1,10));

julia&gt; df = DataFrame(dates = dates, x1 = random(10))

julia&gt; ts = TS(df, :dates)
(10 x 1) TS with Date Index

 Index       x1        
 Date        Float64   
───────────────────────
 2017-01-01  0.768448
 2017-01-02  0.940515
 2017-01-03  0.673959
 2017-01-04  0.395453
 2017-01-05  0.313244
 2017-01-06  0.662555
 2017-01-07  0.586022
 2017-01-08  0.0521332
 2017-01-09  0.26864
 2017-01-10  0.108871


julia&gt; ts = TS(DataFrame(x1=random(10)), dates)


julia&gt; ts = TS(random(10))
(10 x 1) TS with Int64 Index

 Index  x1        
 Int64  Float64   
──────────────────
     1  0.768448
     2  0.940515
     3  0.673959
     4  0.395453
     5  0.313244
     6  0.662555
     7  0.586022
     8  0.0521332
     9  0.26864
    10  0.108871

julia&gt; ts = TS(random(10), dates);


julia&gt; ts = TS([random(10) random(10)], dates) # matrix object
(10 x 2) TS with Date Index

 Index       x1         x2        
 Date        Float64    Float64   
──────────────────────────────────
 2017-01-01  0.768448   0.768448
 2017-01-02  0.940515   0.940515
 2017-01-03  0.673959   0.673959
 2017-01-04  0.395453   0.395453
 2017-01-05  0.313244   0.313244
 2017-01-06  0.662555   0.662555
 2017-01-07  0.586022   0.586022
 2017-01-08  0.0521332  0.0521332
 2017-01-09  0.26864    0.26864
 2017-01-10  0.108871   0.108871
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L44-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{TS, Int64}" href="#Base.getindex-Tuple{TS, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Subsetting/Indexing</strong></p><p><code>TS</code> can be subset using row and column indices. The row selector could be an integer, a range, an array or it could also be a <code>Date</code> object or an ISO-formatted date string (&quot;2007-04-10&quot;). There are methods to subset on year, year-month, and year-quarter.</p><p>The latter two subset <code>coredata</code> by matching on the index column.</p><p>Column selector could be an integer or any other selector which <code>DataFrame</code> indexing supports. To fetch the index column one can use the <code>index()</code> method on the <code>TS</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random;

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; ts = TS([random(10) random(10) random(10)])

# first row
julia&gt; ts[1]            |&gt; print
(1 x 3) TS with Int64 Index

 Index  x1        x2        x3
 Int64  Float64   Float64   Float64
─────────────────────────────────────
     1  0.768448  0.768448  0.768448


# first five rows
julia&gt; ts[1:5]          |&gt; print
(5 x 3) TS with Int64 Index

 Index  x1        x2        x3
 Int64  Float64   Float64   Float64
─────────────────────────────────────
     1  0.768448  0.768448  0.768448
     2  0.940515  0.940515  0.940515
     3  0.673959  0.673959  0.673959
     4  0.395453  0.395453  0.395453
     5  0.313244  0.313244  0.313244


# first five rows, second column
julia&gt; ts[1:5, 2]       |&gt; print
(5 x 1) TS with Int64 Index

 Index  x2
 Int64  Float64
─────────────────
     1  0.768448
     2  0.940515
     3  0.673959
     4  0.395453
     5  0.313244


julia&gt; ts[1:5, 2:3]     |&gt; print

# individual rows
julia&gt; ts[[1, 9]]     |&gt; print


julia&gt; dates = collect(Date(2007):Day(1):Date(2008, 2, 22));


julia&gt; ts = TS(random(length(dates)), dates);


julia&gt; ts[Date(2007, 01, 01)]           |&gt; print
(1 x 1) TS with Dates.Date Index

 Index       x1
 Date        Float64
──────────────────────
 2007-01-01  0.768448


julia&gt; ts[Date(2007)]           |&gt; print
(1 x 1) TS with Dates.Date Index

 Index       x1
 Date        Float64
──────────────────────
 2007-01-01  0.768448


julia&gt; ts[Year(2007)]           |&gt; print
(365 x 1) TS with Dates.Date Index

 Index       x1
 Date        Float64
───────────────────────
 2007-01-01  0.768448
 2007-01-02  0.940515
 2007-01-03  0.673959
 2007-01-04  0.395453
 2007-01-05  0.313244
 2007-01-06  0.662555
 2007-01-07  0.586022
 2007-01-08  0.0521332
     ⋮           ⋮
 2007-12-24  0.468421
 2007-12-25  0.0246652
 2007-12-26  0.171042
 2007-12-27  0.227369
 2007-12-28  0.695758
 2007-12-29  0.417124
 2007-12-30  0.603757
 2007-12-31  0.346659
       349 rows omitted


julia&gt; ts[Year(2007), Month(11)];


julia&gt; ts[Year(2007), Quarter(2)];


julia&gt; ts[&quot;2007-01-01&quot;]


julia&gt; ts[1, :x1]               |&gt; print
(1 x 1) TS with Dates.Date Index

 Index       x1
 Date        Float64
──────────────────────
 2007-01-01  0.768448


julia&gt; ts[1, &quot;x1&quot;]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L324-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.join-Tuple{TS, TS}" href="#Base.join-Tuple{TS, TS}"><code>Base.join</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Joins/Column-binding</strong></p><p><code>TS</code> objects can be combined together column-wise using <code>Index</code> as the column key. There are four kinds of column-binding operations possible as of now. Each join operation works by performing a Set operation on the <code>Index</code> column and then merging the datasets based on the output from the Set operation. Each operation changes column names in the final object automatically if the operation encounters duplicate column names amongst the TS objects.</p><p>The following join types are supported:</p><p><code>join(ts1::TS, ts2::TS, ::JoinBoth)</code></p><p>a.k.a. inner join, takes the intersection of the indexes of <code>ts1</code> and <code>ts2</code>, and then merges the columns of both the objects. The resulting object will only contain rows which are present in both the objects&#39; indexes. The function will renamine the columns in the final object if they had same names in the TS objects.</p><p><code>join(ts1::TS, ts2::TS, ::JoinAll)</code>:</p><p>a.k.a. outer join, takes the union of the indexes of <code>ts1</code> and <code>ts2</code> before merging the other columns of input objects. The output will contain rows which are present in all the input objects while inserting <code>missing</code> values where a row was not present in any of the objects. This is the default behaviour if no <code>JoinType</code> object is provided.</p><p><code>join(ts1::TS, ts2::TS, ::JoinLeft)</code>:</p><p>Left join takes the index values which are present in the left object <code>ts1</code> and finds matching index values in the right object <code>ts2</code>. The resulting object includes all the rows from the left object, the column values from the left object, and the values associated with matching index rows on the right. The operation inserts <code>missing</code> values where in the unmatched rows of the right object.</p><p><code>join(ts1::TS, ts2::TS, ::JoinRight)</code></p><p>Right join, similar to left join but works in the opposite direction. The final object contains all the rows from the right object while inserting <code>missing</code> values in rows missing from the left object.</p><p>The default behaviour is to assume <code>JoinAll()</code> if no <code>JoinType</code> object is provided to the <code>join</code> method.</p><p><code>cbind</code> is an alias for <code>join</code> method.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random;

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; ts1 = TS(random(10), 1:10)


julia&gt; ts2 = TS(random(10), 1:10)


julia&gt; join(ts1, ts2, TSx.JoinAll())


julia&gt; join(ts1, ts2);


julia&gt; join(ts1, ts2, TSx.JoinBoth());


julia&gt; join(ts1, ts2, TSx.JoinLeft());


julia&gt; join(ts1, ts2, TSx.JoinRight());


julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2017,1,10));

julia&gt; ts1 = TS(random(length(dates)), dates) |&gt; print
(10 x 1) TS with Dates.Date Index

 Index       x1
 Date        Float64
───────────────────────
 2017-01-01  0.768448
 2017-01-02  0.940515
 2017-01-03  0.673959
 2017-01-04  0.395453
 2017-01-05  0.313244
 2017-01-06  0.662555
 2017-01-07  0.586022
 2017-01-08  0.0521332
 2017-01-09  0.26864
 2017-01-10  0.108871

julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2017,1,30));

julia&gt; ts2 = TS(random(length(dates)), dates) |&gt; print
(30 x 1) TS with Dates.Date Index

 Index       x1
 Date        Float64
───────────────────────
 2017-01-01  0.768448
 2017-01-02  0.940515
 2017-01-03  0.673959
 2017-01-04  0.395453
 2017-01-05  0.313244
 2017-01-06  0.662555
 2017-01-07  0.586022
 2017-01-08  0.0521332
     ⋮           ⋮
 2017-01-23  0.281066
 2017-01-24  0.792931
 2017-01-25  0.20923
 2017-01-26  0.918165
 2017-01-27  0.614255
 2017-01-28  0.802665
 2017-01-29  0.555668
 2017-01-30  0.940782
        14 rows omitted


julia&gt; join(ts1, ts2) |&gt; print
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L1150-L1279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.names-Tuple{TS}" href="#Base.names-Tuple{TS}"><code>Base.names</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Column names</strong></p><p><code>names(ts::TS)</code></p><p>Return a <code>Vector{String}</code> containing column names of the TS object, excludes index.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; names(TS([1:10 11:20]))
2-element Vector{String}:
 &quot;x1&quot;
 &quot;x2&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L653-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{TS}" href="#Base.size-Tuple{TS}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Size methods</strong></p><p><code>size(ts::TS)</code> Return the number of rows and columns of <code>ts</code> as a tuple.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; TSx.size(TS([collect(1:100) collect(1:100) collect(1:100)]))
(100, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L583-L593">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vcat-Tuple{Vararg{TS}}" href="#Base.vcat-Tuple{Vararg{TS}}"><code>Base.vcat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>vcat(ts::TS...; cols::Symbol=:setequal, source::Symbol=nothing)</p><p>vcat concatenates two or more arrays along dimension 1. This method implements the <code>Base.vcat</code> method.</p><p>The <code>cols</code> keyword argument determines the columns of the data frame <code>:setequal</code>: require all data frames to have the same column names disregarding order. If they appear in different orders, the order of the first provided data frame is used. <code>:orderequal</code>: require all data frames to have the same column names and in the same order. <code>:intersect</code>: only the columns present in all provided data frames are kept. If the intersection is empty, an empty data frame is returned. <code>:union</code>: columns present in at least one of the provided data frames are kept.  Columns not present in some data frames are filled with missing where necessary.</p><p>The <code>source</code> keyword argument, if not nothing (the default), specifies the additional column to be added in the last position in the resulting data frame that will identify the source data frame.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random;

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; dates1 = collect(Date(2017,1,1):Day(1):Date(2017,1,10));

julia&gt; dates2 = collect(Date(2017,1,11):Day(1):Date(2017,1,30));

julia&gt; ts1 = TS(randn(length(dates1)), dates1) |&gt; print
(10 x 1) TS with Dates.Date Index

 Index       x1
 Date        Float64
────────────────────────
 2017-01-01  -0.420348
 2017-01-02   0.109363
 2017-01-03  -0.0702014
 2017-01-04   0.165618
 2017-01-05  -0.0556799
 2017-01-06  -0.147801
 2017-01-07  -2.50723
 2017-01-08  -0.099783
 2017-01-09   0.177526
 2017-01-10  -1.08461

julia&gt; ts2 = TS(randn(length(dates2)), dates2) |&gt; print
(20 x 1) TS with Dates.Date Index

 Index       x1
 Date        Float64
────────────────────────
 2017-01-11   2.15087
 2017-01-12   0.9203
 2017-01-13  -0.0879142
 2017-01-14  -0.930109
 2017-01-15   0.061117
 2017-01-16   0.0434627
 2017-01-17   0.0834733
 2017-01-18  -1.52281
     ⋮           ⋮
 2017-01-23  -0.756143
 2017-01-24   0.491623
 2017-01-25   0.549672
 2017-01-26   0.570689
 2017-01-27  -0.380011
 2017-01-28  -2.09965
 2017-01-29   1.37289
 2017-01-30  -0.462384
          4 rows omitted


julia&gt; # vcat(ts1, ts2);        # FIXME

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L1306-L1380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe" href="#RecipesBase.apply_recipe"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Plottting</strong></p><p><code>plot(ts::TS, cols::Vector{Int} = collect(1:TSx.ncol(ts)))</code> <code>plot(ts::TS, cols::Vector{T}) where {T&lt;:Union{String, Symbol}}</code> <code>plot(ts::TS, cols::T) where {T&lt;:Union{Int, String, Symbol}}</code></p><p>Plots a TS object with the index on the x-axis and selected <code>cols</code> on the y-axis. By default, plot all the columns. Columns can be selected using Int indexes, String(s), or Symbol(s).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dates = Date(&quot;2022-01-01&quot;):Month(1):Date(&quot;2022-01-01&quot;)+Month(11);

julia&gt; df = DataFrame(Index = dates, 
        val1 = randn(12), 
        val2 = randn(12),
        val3 = randn(12));

julia&gt; TS(df)           |&gt; print
(12 x 3) TS with Date Index

 Index       val1       val2       val3       
 Date        Float64    Float64    Float64    
──────────────────────────────────────────────
 2022-01-01  -2.2798    -0.801856  -0.696722
 2022-02-01  -0.266063   0.268206   0.743648
 2022-03-01   1.01839    1.64479   -0.296677
 2022-04-01   2.05753   -1.21628    0.339607
 2022-05-01   0.967545   1.21421    0.893949
 2022-06-01   0.191933  -0.56957   -1.0605
 2022-07-01  -1.73478    0.283089   0.360917
 2022-08-01  -0.305464  -1.55139    0.0505422
 2022-09-01  -2.40175    0.503355   0.743701
 2022-10-01  -0.273021   1.41333   -0.0682414
 2022-11-01   0.469246  -0.765097  -0.0119999
 2022-12-01  -1.12906    0.625611   1.72409


julia&gt; using Plots

julia&gt; plot(ts)

julia&gt; plot(ts[1:6], [:val1, :val3])

julia&gt; plot(ts, [1, 2], size=(600, 400))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L1070-L1117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.apply-Union{Tuple{V}, Tuple{T}, Tuple{TS, Union{Type{T}, T}, V}, Tuple{TS, Union{Type{T}, T}, V, Function}} where {T&lt;:Union{Dates.DatePeriod, Dates.TimePeriod}, V&lt;:Function}" href="#TSx.apply-Union{Tuple{V}, Tuple{T}, Tuple{TS, Union{Type{T}, T}, V}, Tuple{TS, Union{Type{T}, T}, V, Function}} where {T&lt;:Union{Dates.DatePeriod, Dates.TimePeriod}, V&lt;:Function}"><code>TSx.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Apply/Period conversion</strong></p><p><code>apply(ts::TS, period::Union{T,Type{T}},       fun::V,       index_at::Function=first)     where {T&lt;:Union{DatePeriod,TimePeriod}, V&lt;:Function}</code></p><p>Apply <code>fun</code> to <code>ts</code> object based on <code>period</code> and return correctly indexed rows. This method is used for doing aggregation over a time period or to convert <code>ts</code> into an object of lower frequency (ex. from daily series to monthly).</p><p><code>period</code> is any of <code>Period</code> types in the <code>Dates</code> module. Conversion from lower to a higher frequency will throw an error as interpolation isn&#39;t currently handled by this method.</p><p>By default, the method uses the first value of the index within the period to index the resulting aggregated object. This behaviour can be controlled by <code>index_at</code> argument which can take <code>first</code> or <code>last</code> as an input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random, Statistics;
julia&gt; random(x) = rand(MersenneTwister(123), x);
julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2018,3,10));

julia&gt; df = DataFrame(Index = dates, x1 = random(length(dates)))
julia&gt; ts = TS(df) |&gt; print

julia&gt; apply(ts, Month, first) |&gt; print
(15 x 1) TS with Date Index

 Index       x1_first  
 Date        Float64   
───────────────────────
 2017-01-01  0.768448
 2017-02-01  0.790201
 2017-03-01  0.467219
 2017-04-01  0.783473
 2017-05-01  0.651354
 2017-06-01  0.373346
 2017-07-01  0.83296
 2017-08-01  0.132716
 2017-09-01  0.27899
 2017-10-01  0.995414
 2017-11-01  0.214132
 2017-12-01  0.832917
 2018-01-01  0.0409471
 2018-02-01  0.720163
 2018-03-01  0.87459

# alternate months
julia&gt; apply(ts, Month(2), first) |&gt; print
(8 x 1) TS with Date Index

 Index       x1_first  
 Date        Float64   
───────────────────────
 2017-01-01  0.768448
 2017-03-01  0.467219
 2017-05-01  0.651354
 2017-07-01  0.83296
 2017-09-01  0.27899
 2017-11-01  0.214132
 2018-01-01  0.0409471
 2018-03-01  0.87459


julia&gt; ts_weekly = apply(ts, Week, Statistics.std) # weekly standard deviation
julia&gt; show(ts_weekly)

julia&gt; ts_weekly = apply(ts, Week, Statistics.std, last) # indexed by last date of the week
julia&gt; show(ts_weekly)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L673-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.index-Tuple{TS}" href="#TSx.index-Tuple{TS}"><code>TSx.index</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Index column</strong></p><p>Return the index vector from the <code>coredata</code> DataFrame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random;

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; ts = TS(random(10), Date(&quot;2022-02-01&quot;):Month(1):Date(&quot;2022-02-01&quot;)+Month(9));


julia&gt; show(ts)
(10 x 1) TS with Dates.Date Index

 Index       x1
 Date        Float64
───────────────────────
 2022-02-01  0.768448
 2022-03-01  0.940515
 2022-04-01  0.673959
 2022-05-01  0.395453
 2022-06-01  0.313244
 2022-07-01  0.662555
 2022-08-01  0.586022
 2022-09-01  0.0521332
 2022-10-01  0.26864
 2022-11-01  0.108871

julia&gt; index(ts)
10-element Vector{Date}:
 2022-02-01
 2022-03-01
 2022-04-01
 2022-05-01
 2022-06-01
 2022-07-01
 2022-08-01
 2022-09-01
 2022-10-01
 2022-11-01

julia&gt;  eltype(index(ts))
Date</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L601-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.lag" href="#TSx.lag"><code>TSx.lag</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Lagging</strong></p><p><code>lag(ts::TS, lag_value::Int = 1)</code></p><p>Lag the <code>ts</code> object by the specified <code>lag_value</code>. The rows corresponding to lagged values will be rendered as <code>missing</code>. Negative values of lag are also accepted (see <code>TSx.lead</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random, Statistics;

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2017,1,10));


julia&gt; ts = TS(DataFrame(Index = dates, x1 = random(length(dates)))) |&gt; print
(10 x 1) TS with Dates.Date Index

 Index       x1
 Date        Float64
───────────────────────
 2017-01-01  0.768448
 2017-01-02  0.940515
 2017-01-03  0.673959
 2017-01-04  0.395453
 2017-01-05  0.313244
 2017-01-06  0.662555
 2017-01-07  0.586022
 2017-01-08  0.0521332
 2017-01-09  0.26864
 2017-01-10  0.108871


julia&gt; l = lag(ts)
julia&gt; show(l)

julia&gt; l = lag(ts, 2) # Lags by 2 values;
julia&gt; show(l)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L768-L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.lead" href="#TSx.lead"><code>TSx.lead</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Leading</strong></p><p><code>lead(ts::TS, lead_value::Int = 1)</code></p><p>Similar to lag, this method leads the <code>ts</code> object by <code>lead_value</code>. The lead rows are inserted with <code>missing</code>. Negative values of lead are also accepted (see <code>TSx.lag</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random, Statistics;

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2018,3,10));


julia&gt; ts = TS(DataFrame(Index = dates, x1 = random(length(dates)))) |&gt; print
(434 x 1) TS with Dates.Date Index

 Index       x1
 Date        Float64
───────────────────────
 2017-01-01  0.768448
 2017-01-02  0.940515
 2017-01-03  0.673959
 2017-01-04  0.395453
 2017-01-05  0.313244
 2017-01-06  0.662555
 2017-01-07  0.586022
 2017-01-08  0.0521332
     ⋮           ⋮
 2018-03-03  0.127635
 2018-03-04  0.147813
 2018-03-05  0.873555
 2018-03-06  0.486486
 2018-03-07  0.495525
 2018-03-08  0.64075
 2018-03-09  0.375126
 2018-03-10  0.0338698
       418 rows omitted


julia&gt; lead(ts) |&gt; print # Leads once

julia&gt; lead(ts, 2) # Leads by 2 values
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L817-L865">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.log" href="#TSx.log"><code>TSx.log</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Log Function</strong></p><p><code>log(ts::TS, complex::Bool = false)</code></p><p>This method computes the log value of the non-index columns in the TS object.</p><p>If the <code>complex</code> argument is <code>true</code> the function returns the log of negative numbers as complex numbers.  But this also coerces the log of positive values as complex numbers with the imaginary component equal to 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L947-L959">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.ncol-Tuple{TS}" href="#TSx.ncol-Tuple{TS}"><code>TSx.ncol</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Size methods</strong></p><p><code>ncol(ts::TS)</code></p><p>Return the number of columns of <code>ts</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random;

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; TSx.ncol(TS([random(100) random(100) random(100)]))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L561-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.nrow-Tuple{TS}" href="#TSx.nrow-Tuple{TS}"><code>TSx.nrow</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Size methods</strong></p><p><code>nrow(ts::TS)</code> Return the number of rows of <code>ts</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ts = TS(collect(1:10))


julia&gt; TSx.nrow(ts)
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L542-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.rollapply-Tuple{Function, TS, Any, Int64}" href="#TSx.rollapply-Tuple{Function, TS, Any, Int64}"><code>TSx.rollapply</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Rolling Functions</strong></p><p><code>rollapply(fun::Function, ts::TS, column::Any, windowsize::Int)</code></p><p>Apply a function to a column of <code>ts</code> for each continuous set of rows of size <code>windowsize</code>. <code>column</code> could be any of the <code>DataFrame</code> column selectors.</p><p>The output is a TS object with <code>(nrow(ts) - windowsize + 1)</code> rows indexed with the last index value of each window.</p><p>This method uses <code>RollingFunctions</code> package to implement this functionality.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ts = TS(1:12, Date(&quot;2022-02-01&quot;):Month(1):Date(&quot;2022-02-01&quot;)+Month(11))

julia&gt; show(ts)
(12 x 1) TS with Dates.Date Index

 Index       x1
 Date        Int64
───────────────────
 2022-02-01      1
 2022-03-01      2
 2022-04-01      3
 2022-05-01      4
 2022-06-01      5
 2022-07-01      6
 2022-08-01      7
 2022-09-01      8
 2022-10-01      9
 2022-11-01     10
 2022-12-01     11
 2023-01-01     12

julia&gt; rollapply(sum, ts, :x1, 10) |&gt; print
(3 x 1) TS with Dates.Date Index

 Index       x1_rolling_sum
 Date        Float64
────────────────────────────
 2022-11-01            55.0
 2022-12-01            65.0
 2023-01-01            75.0

julia&gt; rollapply(Statistics.mean, ts, 1, 5) |&gt; print
(8 x 1) TS with Dates.Date Index

 Index       x1_rolling_mean
 Date        Float64
─────────────────────────────
 2022-06-01              3.0
 2022-07-01              4.0
 2022-08-01              5.0
 2022-09-01              6.0
 2022-10-01              7.0
 2022-11-01              8.0
 2022-12-01              9.0
 2023-01-01             10.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/e831f0944b2f9dfb0b678e35141ab332ce57360a/src/TSx.jl#L982-L1047">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Friday 22 April 2022 12:34">Friday 22 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
