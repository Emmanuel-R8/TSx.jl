<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TSx.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://xKDR.github.io/TSx.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TSx.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/xKDR/TSx.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TSx"><a class="docs-heading-anchor" href="#TSx">TSx</a><a id="TSx-1"></a><a class="docs-heading-anchor-permalink" href="#TSx" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/xKDR/TSx.jl">TSx</a>.</p><ul><li><a href="#TSx.TS"><code>TSx.TS</code></a></li><li><a href="#Base.getindex-Tuple{TS, Int64}"><code>Base.getindex</code></a></li><li><a href="#Base.join-Tuple{TS, TS}"><code>Base.join</code></a></li><li><a href="#Base.size-Tuple{TS}"><code>Base.size</code></a></li><li><a href="#Base.vcat-Tuple{Vararg{TS}}"><code>Base.vcat</code></a></li><li><a href="#TSx.apply-Union{Tuple{V}, Tuple{T}, Tuple{TS, Union{Type{T}, T}, V}, Tuple{TS, Union{Type{T}, T}, V, Function}} where {T&lt;:Union{Dates.DatePeriod, Dates.TimePeriod}, V&lt;:Function}"><code>TSx.apply</code></a></li><li><a href="#TSx.index-Tuple{TS}"><code>TSx.index</code></a></li><li><a href="#TSx.lag"><code>TSx.lag</code></a></li><li><a href="#TSx.lead"><code>TSx.lead</code></a></li><li><a href="#TSx.log"><code>TSx.log</code></a></li><li><a href="#TSx.ncol-Tuple{TS}"><code>TSx.ncol</code></a></li><li><a href="#TSx.nrow-Tuple{TS}"><code>TSx.nrow</code></a></li><li><a href="#TSx.plot"><code>TSx.plot</code></a></li><li><a href="#TSx.rollapply-Tuple{Function, TS, Any, Int64}"><code>TSx.rollapply</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TSx.TS" href="#TSx.TS"><code>TSx.TS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TS
  coredata :: DataFrame
end</code></pre><p><code>::TS</code> - A type to hold ordered data with an index.</p><p>A TS object is essentially a <code>DataFrame</code> with a specific column marked as an index and has the name <code>Index</code>. The DataFrame is sorted using index values during construction.</p><p>Permitted data inputs to constructor are DataFrame, Vector, and 2-dimensional Array. If an index is already not present in the constructor then it is generated.</p><p>Since <code>TS.coredata</code> is a DataFrame it can be operated upon independently using methods provided by the DataFrames package (ex. <code>transform</code>, <code>combine</code>, etc.).</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">TS(coredata::DataFrame, index::Union{String, Symbol, Int}=1)
TS(coredata::DataFrame, index::AbstractVector{T}) where {T&lt;:Int}
TS(coredata::DataFrame, index::UnitRange{Int})
TS(coredata::AbstractVector{T}, index::AbstractVector{V}) where {T, V}
TS(coredata::AbstractVector{T}) where {T}
TS(coredata::AbstractArray{T,2}) where {T}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TSx, DataFrames, Random;

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; df = DataFrame(x1 = random(10)); 

julia&gt; TS(df)             |&gt; print  # generates index
10×2 DataFrame
 Row │ Index  x1        
     │ Int64  Float64   
─────┼──────────────────
   1 │     1  0.768448
   2 │     2  0.940515
   3 │     3  0.673959
   4 │     4  0.395453
   5 │     5  0.313244
   6 │     6  0.662555
   7 │     7  0.586022
   8 │     8  0.0521332
   9 │     9  0.26864
  10 │    10  0.108871

Index: {Int64} [10]
Size: (10, 1)

julia&gt; df = DataFrame(ind = [1, 2, 3], x1 = random(3));

julia&gt; TS(df, 1) |&gt; print # first column is index 
3×2 DataFrame
 Row │ Index  x1       
     │ Int64  Float64  
─────┼─────────────────
   1 │     1  0.768448
   2 │     2  0.940515
   3 │     3  0.673959

Index: {Int64} [3]
Size: (3, 1)

julia&gt; df = DataFrame(x1 = random(3), x2 = random(3), Index = [1, 2, 3]);

julia&gt; TS(df)  |&gt; print   # looks up `Index` column 
3×3 DataFrame
 Row │ Index  x1        x2       
     │ Int64  Float64   Float64  
─────┼───────────────────────────
   1 │     1  0.768448  0.768448
   2 │     2  0.940515  0.940515
   3 │     3  0.673959  0.673959

Index: {Int64} [3]
Size: (3, 2)

julia&gt; using Dates;

julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2017,1,10));

julia&gt; df = DataFrame(dates = dates, x1 = random(10));

julia&gt; TS(df, :dates) |&gt; print
10×2 DataFrame
 Row │ Index       x1        
     │ Date        Float64   
─────┼───────────────────────
   1 │ 2017-01-01  0.768448
   2 │ 2017-01-02  0.940515
   3 │ 2017-01-03  0.673959
   4 │ 2017-01-04  0.395453
   5 │ 2017-01-05  0.313244
   6 │ 2017-01-06  0.662555
   7 │ 2017-01-07  0.586022
   8 │ 2017-01-08  0.0521332
   9 │ 2017-01-09  0.26864
  10 │ 2017-01-10  0.108871

Index: {Dates.Date} [10]
Size: (10, 1)

julia&gt; TS(DataFrame(x1=random(10)), dates) |&gt; print
10×2 DataFrame
 Row │ Index       x1        
     │ Date        Float64   
─────┼───────────────────────
   1 │ 2017-01-01  0.768448
   2 │ 2017-01-02  0.940515
   3 │ 2017-01-03  0.673959
   4 │ 2017-01-04  0.395453
   5 │ 2017-01-05  0.313244
   6 │ 2017-01-06  0.662555
   7 │ 2017-01-07  0.586022
   8 │ 2017-01-08  0.0521332
   9 │ 2017-01-09  0.26864
  10 │ 2017-01-10  0.108871

Index: {Dates.Date} [10]
Size: (10, 1)

julia&gt; TS(random(10)) |&gt; print
10×2 DataFrame
 Row │ Index  x1        
     │ Int64  Float64   
─────┼──────────────────
   1 │     1  0.768448
   2 │     2  0.940515
   3 │     3  0.673959
   4 │     4  0.395453
   5 │     5  0.313244
   6 │     6  0.662555
   7 │     7  0.586022
   8 │     8  0.0521332
   9 │     9  0.26864
  10 │    10  0.108871

Index: {Int64} [10]
Size: (10, 1)


julia&gt; TS(random(10), dates) |&gt; print
10×2 DataFrame
 Row │ Index       x1        
     │ Date        Float64   
─────┼───────────────────────
   1 │ 2017-01-01  0.768448
   2 │ 2017-01-02  0.940515
   3 │ 2017-01-03  0.673959
   4 │ 2017-01-04  0.395453
   5 │ 2017-01-05  0.313244
   6 │ 2017-01-06  0.662555
   7 │ 2017-01-07  0.586022
   8 │ 2017-01-08  0.0521332
   9 │ 2017-01-09  0.26864
  10 │ 2017-01-10  0.108871

Index: {Dates.Date} [10]
Size: (10, 1)

julia&gt; TS([random(10) random(10)], dates) |&gt; print # matrix object
10×3 DataFrame
 Row │ Index       x1         x2        
     │ Date        Float64    Float64   
─────┼──────────────────────────────────
   1 │ 2017-01-01  0.768448   0.768448
   2 │ 2017-01-02  0.940515   0.940515
   3 │ 2017-01-03  0.673959   0.673959
   4 │ 2017-01-04  0.395453   0.395453
   5 │ 2017-01-05  0.313244   0.313244
   6 │ 2017-01-06  0.662555   0.662555
   7 │ 2017-01-07  0.586022   0.586022
   8 │ 2017-01-08  0.0521332  0.0521332
   9 │ 2017-01-09  0.26864    0.26864
  10 │ 2017-01-10  0.108871   0.108871

Index: {Dates.Date} [10]
Size: (10, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L44-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{TS, Int64}" href="#Base.getindex-Tuple{TS, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Subsetting/Indexing</strong></p><p><code>TS</code> can be subset using row and column indices. The row selector could be an integer, a range, an array or it could also be a <code>Date</code> object or an ISO-formatted date string (&quot;2007-04-10&quot;). There are methods to subset on year, year-month, and year-quarter.</p><p>The latter two subset <code>coredata</code> by matching on the index column.</p><p>Column selector could be an integer or any other selector which <code>DataFrame</code> indexing supports. To fetch the index column one can use the <code>index()</code> method on the <code>TS</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TSx, DataFrames, Random, Dates;

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; ts = TS([random(10) random(10) random(10)]); 

julia&gt; ts[1] |&gt; print
1×4 DataFrame
 Row │ Index  x1        x2        x3       
     │ Int64  Float64   Float64   Float64  
─────┼─────────────────────────────────────
   1 │     1  0.768448  0.768448  0.768448

Index: {Int64} [1]
Size: (1, 3)

julia&gt; ts[1:5] |&gt; print
5×4 DataFrame
 Row │ Index  x1        x2        x3       
     │ Int64  Float64   Float64   Float64  
─────┼─────────────────────────────────────
   1 │     1  0.768448  0.768448  0.768448
   2 │     2  0.940515  0.940515  0.940515
   3 │     3  0.673959  0.673959  0.673959
   4 │     4  0.395453  0.395453  0.395453
   5 │     5  0.313244  0.313244  0.313244

Index: {Int64} [5]
Size: (5, 3)

julia&gt; ts[1:5, 2] |&gt; print
5×2 DataFrame
 Row │ Index  x2       
     │ Int64  Float64  
─────┼─────────────────
   1 │     1  0.768448
   2 │     2  0.940515
   3 │     3  0.673959
   4 │     4  0.395453
   5 │     5  0.313244

Index: {Int64} [5]
Size: (5, 1)

julia&gt; ts[1:5, 2:3] |&gt; print
5×3 DataFrame
 Row │ Index  x2        x3       
     │ Int64  Float64   Float64  
─────┼───────────────────────────
   1 │     1  0.768448  0.768448
   2 │     2  0.940515  0.940515
   3 │     3  0.673959  0.673959
   4 │     4  0.395453  0.395453
   5 │     5  0.313244  0.313244

Index: {Int64} [5]
Size: (5, 2)

julia&gt; ts[[1, 9]] |&gt; print               # individual rows
2×4 DataFrame
 Row │ Index  x1        x2        x3       
     │ Int64  Float64   Float64   Float64  
─────┼─────────────────────────────────────
   1 │     1  0.768448  0.768448  0.768448
   2 │     9  0.26864   0.26864   0.26864

Index: {Int64} [2]
Size: (2, 3)

julia&gt; dates = collect(Date(2007):Day(1):Date(2008, 2, 22));

julia&gt; ts = TS(random(length(dates)), dates); 

julia&gt; ts[Date(2007, 01, 01)] |&gt; print
1×2 DataFrame
 Row │ Index       x1       
     │ Date        Float64  
─────┼──────────────────────
   1 │ 2007-01-01  0.768448

Index: {Dates.Date} [1]
Size: (1, 1)

julia&gt; ts[Date(2007)] |&gt; print
1×2 DataFrame
 Row │ Index       x1       
     │ Date        Float64  
─────┼──────────────────────
   1 │ 2007-01-01  0.768448

Index: {Dates.Date} [1]
Size: (1, 1)

julia&gt; ts[Year(2007)]; 

julia&gt; ts[Year(2007), Month(11)]; 

julia&gt; ts[Year(2007), Quarter(2)]; 

julia&gt; ts[&quot;2007-01-01&quot;] |&gt; print
1×2 DataFrame
 Row │ Index       x1       
     │ Date        Float64  
─────┼──────────────────────
   1 │ 2007-01-01  0.768448

Index: {Dates.Date} [1]
Size: (1, 1)

julia&gt; ts[1, :x1] |&gt; print
1×2 DataFrame
 Row │ Index       x1       
     │ Date        Float64  
─────┼──────────────────────
   1 │ 2007-01-01  0.768448

Index: {Dates.Date} [1]
Size: (1, 1)

julia&gt; ts[1, &quot;x1&quot;] |&gt; print
1×2 DataFrame
 Row │ Index       x1       
     │ Date        Float64  
─────┼──────────────────────
   1 │ 2007-01-01  0.768448

Index: {Dates.Date} [1]
Size: (1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L356-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.join-Tuple{TS, TS}" href="#Base.join-Tuple{TS, TS}"><code>Base.join</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Joins/Column-binding</strong></p><p><code>TS</code> objects can be combined together column-wise using <code>Index</code> as the column key. There are four kinds of column-binding operations possible as of now. Each join operation works by performing a Set operation on the <code>Index</code> column and then merging the datasets based on the output from the Set operation. Each operation changes column names in the final object automatically if the operation encounters duplicate column names amongst the TS objects.</p><p>The following join types are supported:</p><p><code>join(ts1::TS, ts2::TS, ::JoinBoth)</code></p><p>a.k.a. inner join, takes the intersection of the indexes of <code>ts1</code> and <code>ts2</code>, and then merges the columns of both the objects. The resulting object will only contain rows which are present in both the objects&#39; indexes. The function will renamine the columns in the final object if they had same names in the TS objects.</p><p><code>join(ts1::TS, ts2::TS, ::JoinAll)</code>:</p><p>a.k.a. outer join, takes the union of the indexes of <code>ts1</code> and <code>ts2</code> before merging the other columns of input objects. The output will contain rows which are present in all the input objects while inserting <code>missing</code> values where a row was not present in any of the objects. This is the default behaviour if no <code>JoinType</code> object is provided.</p><p><code>join(ts1::TS, ts2::TS, ::JoinLeft)</code>:</p><p>Left join takes the index values which are present in the left object <code>ts1</code> and finds matching index values in the right object <code>ts2</code>. The resulting object includes all the rows from the left object, the column values from the left object, and the values associated with matching index rows on the right. The operation inserts <code>missing</code> values where in the unmatched rows of the right object.</p><p><code>join(ts1::TS, ts2::TS, ::JoinRight)</code></p><p>Right join, similar to left join but works in the opposite direction. The final object contains all the rows from the right object while inserting <code>missing</code> values in rows missing from the left object.</p><p>The default behaviour is to assume <code>JoinAll()</code> if no <code>JoinType</code> object is provided to the <code>join</code> method.</p><p><code>cbind</code> is an alias for <code>join</code> method.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TSx, Dates, Random, DataFrames; 

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; ts1 = TS(random(10), 1:10); 

julia&gt; ts2 = TS(random(10), 1:10); 

julia&gt; join(ts1, ts2, TSx.JoinAll()) |&gt; print
10×3 DataFrame
 Row │ Index  x1         x1_1      
     │ Int64  Float64?   Float64?  
─────┼─────────────────────────────
   1 │     1  0.768448   0.768448
   2 │     2  0.940515   0.940515
   3 │     3  0.673959   0.673959
   4 │     4  0.395453   0.395453
   5 │     5  0.313244   0.313244
   6 │     6  0.662555   0.662555
   7 │     7  0.586022   0.586022
   8 │     8  0.0521332  0.0521332
   9 │     9  0.26864    0.26864
  10 │    10  0.108871   0.108871

Index: {Int64} [10]
Size: (10, 2)

julia&gt; join(ts1, ts2);             # same as JoinAll()

julia&gt; join(ts1, ts2, TSx.JoinBoth());

julia&gt; join(ts1, ts2, TSx.JoinLeft()); 

julia&gt; join(ts1, ts2, TSx.JoinRight());

julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2017,1,10))
10-element Vector{Date}:
 2017-01-01
 2017-01-02
 2017-01-03
 2017-01-04
 2017-01-05
 2017-01-06
 2017-01-07
 2017-01-08
 2017-01-09
 2017-01-10

julia&gt; ts1 = TS(random(length(dates)), dates); 

julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2017,1,30)); 

julia&gt; ts2 = TS(random(length(dates)), dates); 

julia&gt; join(ts1, ts2); </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L1107-L1217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{TS}" href="#Base.size-Tuple{TS}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Size methods</strong></p><p><code>size(ts::TS)</code> Return the number of rows and columns of <code>ts</code> as a tuple.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TSx; 

julia&gt; TS([collect(1:100) collect(1:100) collect(1:100)]) |&gt; size
(100, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L620-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vcat-Tuple{Vararg{TS}}" href="#Base.vcat-Tuple{Vararg{TS}}"><code>Base.vcat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>vcat(ts::TS...; cols::Symbol=:setequal, source::Symbol=nothing)</p><p>vcat concatenates two or more arrays along dimension 1. This method implements the <code>Base.vcat</code> method.</p><p>The <code>cols</code> keyword argument determines the columns of the data frame <code>:setequal</code>: require all data frames to have the same column names disregarding order.  If they appear in different orders, the order of the first provided data frame is used. <code>:orderequal</code>: require all data frames to have the same column names and in the same order. <code>:intersect</code>: only the columns present in all provided data frames are kept. If the intersection is empty, an empty data frame is returned. <code>:union</code>: columns present in at least one of the provided data frames are kept.   Columns not present in some data frames are filled with missing where necessary.</p><p>The <code>source</code> keyword argument, if not nothing (the default), specifies the additional column  to be added in the last position in the resulting data frame that will identify the source data frame.   </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TSx, DataFrames, Dates, Random;

julia&gt; random(x) = rand(MersenneTwister(123), x); 

julia&gt; dates1 = collect(Date(2017,1,1):Day(1):Date(2017,1,10))
10-element Vector{Date}:
 2017-01-01
 2017-01-02
 2017-01-03
 2017-01-04
 2017-01-05
 2017-01-06
 2017-01-07
 2017-01-08
 2017-01-09
 2017-01-10

julia&gt; TS(random(length(dates1)), dates1) |&gt; print
10×2 DataFrame
 Row │ Index       x1        
     │ Date        Float64   
─────┼───────────────────────
   1 │ 2017-01-01  0.768448
   2 │ 2017-01-02  0.940515
   3 │ 2017-01-03  0.673959
   4 │ 2017-01-04  0.395453
   5 │ 2017-01-05  0.313244
   6 │ 2017-01-06  0.662555
   7 │ 2017-01-07  0.586022
   8 │ 2017-01-08  0.0521332
   9 │ 2017-01-09  0.26864
  10 │ 2017-01-10  0.108871

Index: {Dates.Date} [10]
Size: (10, 1)

julia&gt; dates2 = collect(Date(2017,1,11):Day(1):Date(2017,1,30)); 

julia&gt; TS(random(length(dates2)), dates2) |&gt; print
20×2 DataFrame
 Row │ Index       x1        
     │ Date        Float64   
─────┼───────────────────────
   1 │ 2017-01-11  0.768448
   2 │ 2017-01-12  0.940515
   3 │ 2017-01-13  0.673959
   4 │ 2017-01-14  0.395453
   5 │ 2017-01-15  0.313244
   6 │ 2017-01-16  0.662555
   7 │ 2017-01-17  0.586022
   8 │ 2017-01-18  0.0521332
   9 │ 2017-01-19  0.26864
  10 │ 2017-01-20  0.108871
  11 │ 2017-01-21  0.163666
  12 │ 2017-01-22  0.473017
  13 │ 2017-01-23  0.865412
  14 │ 2017-01-24  0.617492
  15 │ 2017-01-25  0.285698
  16 │ 2017-01-26  0.463847
  17 │ 2017-01-27  0.275819
  18 │ 2017-01-28  0.446568
  19 │ 2017-01-29  0.582318
  20 │ 2017-01-30  0.255981

Index: {Dates.Date} [20]
Size: (20, 1)

julia&gt; ts1 = TS(randn(length(dates1)), dates1); 

julia&gt; ts2 = TS(randn(length(dates2)), dates2); 

julia&gt; # vcat(ts1, ts2); 

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L1244-L1339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.apply-Union{Tuple{V}, Tuple{T}, Tuple{TS, Union{Type{T}, T}, V}, Tuple{TS, Union{Type{T}, T}, V, Function}} where {T&lt;:Union{Dates.DatePeriod, Dates.TimePeriod}, V&lt;:Function}" href="#TSx.apply-Union{Tuple{V}, Tuple{T}, Tuple{TS, Union{Type{T}, T}, V}, Tuple{TS, Union{Type{T}, T}, V, Function}} where {T&lt;:Union{Dates.DatePeriod, Dates.TimePeriod}, V&lt;:Function}"><code>TSx.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Apply/Period conversion</strong></p><p><code>apply(ts::TS, period::Union{T,Type{T}},       fun::V,       index_at::Function=first)      where {T&lt;:Union{DatePeriod,TimePeriod}, V&lt;:Function}</code></p><p>Apply <code>fun</code> to <code>ts</code> object based on <code>period</code> and return correctly indexed rows. This method is used for doing aggregation over a time period or to convert <code>ts</code> into an object of lower frequency (ex. from daily series to monthly).</p><p><code>period</code> is any of <code>Period</code> types in the <code>Dates</code> module. Conversion from lower to a higher frequency will throw an error as interpolation isn&#39;t currently handled by this method.</p><p>By default, the method uses the first value of the index within the period to index the resulting aggregated object. This behaviour can be controlled by <code>index_at</code> argument which can take <code>first</code> or <code>last</code> as an input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TSx, Dates, Random, Statistics, DataFrames; 

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2018,3,10)); 

julia&gt; ts = TS(DataFrame(Index = dates, x1 = random(length(dates)))); 

julia&gt; apply(ts, Month, first) |&gt; print
15×2 DataFrame
 Row │ Index       x1_first  
     │ Date        Float64   
─────┼───────────────────────
   1 │ 2017-01-01  0.768448
   2 │ 2017-02-01  0.790201
   3 │ 2017-03-01  0.467219
   4 │ 2017-04-01  0.783473
   5 │ 2017-05-01  0.651354
   6 │ 2017-06-01  0.373346
   7 │ 2017-07-01  0.83296
   8 │ 2017-08-01  0.132716
   9 │ 2017-09-01  0.27899
  10 │ 2017-10-01  0.995414
  11 │ 2017-11-01  0.214132
  12 │ 2017-12-01  0.832917
  13 │ 2018-01-01  0.0409471
  14 │ 2018-02-01  0.720163
  15 │ 2018-03-01  0.87459

Index: {Dates.Date} [15]
Size: (15, 1)

julia&gt; apply(ts, Month(2), first) |&gt; print # alternate months
8×2 DataFrame
 Row │ Index       x1_first  
     │ Date        Float64   
─────┼───────────────────────
   1 │ 2017-01-01  0.768448
   2 │ 2017-03-01  0.467219
   3 │ 2017-05-01  0.651354
   4 │ 2017-07-01  0.83296
   5 │ 2017-09-01  0.27899
   6 │ 2017-11-01  0.214132
   7 │ 2018-01-01  0.0409471
   8 │ 2018-03-01  0.87459

Index: {Dates.Date} [8]
Size: (8, 1)

julia&gt; ts_monthly = apply(ts, Week, Statistics.std) # weekly standard deviation;

julia&gt; ts_monthly = apply(ts, Week, Statistics.std, last) # indexed by last date of the week; 
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L699-L776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.index-Tuple{TS}" href="#TSx.index-Tuple{TS}"><code>TSx.index</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Index column</strong></p><p>Return the index vector from the TS DataFrame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Dates, TSx, Random; 

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; ts = TS(random(10), Date(&quot;2022-02-01&quot;):Month(1):Date(&quot;2022-02-01&quot;)+Month(9)); 

julia&gt; ts |&gt; print
10×2 DataFrame
 Row │ Index       x1        
     │ Date        Float64   
─────┼───────────────────────
   1 │ 2022-02-01  0.768448
   2 │ 2022-03-01  0.940515
   3 │ 2022-04-01  0.673959
   4 │ 2022-05-01  0.395453
   5 │ 2022-06-01  0.313244
   6 │ 2022-07-01  0.662555
   7 │ 2022-08-01  0.586022
   8 │ 2022-09-01  0.0521332
   9 │ 2022-10-01  0.26864
  10 │ 2022-11-01  0.108871

Index: {Dates.Date} [10]
Size: (10, 1)

julia&gt; ts |&gt; TSx.index 
10-element Vector{Date}:
 2022-02-01
 2022-03-01
 2022-04-01
 2022-05-01
 2022-06-01
 2022-07-01
 2022-08-01
 2022-09-01
 2022-10-01
 2022-11-01

julia&gt;  ts |&gt; TSx.index |&gt; typeof 
Vector{Date} (alias for Array{Date, 1})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L640-L688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.lag" href="#TSx.lag"><code>TSx.lag</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Lagging</strong></p><p><code>lag(ts::TS, lag_value::Int = 1)</code></p><p>Lag the <code>ts</code> object by the specified <code>lag_value</code>. The rows corresponding to lagged values will be rendered as <code>missing</code>. Negative values of lag are also accepted (see <code>TSx.lead</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TSx, Dates, Random, Statistics, DataFrames; 

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2017,1,10));

julia&gt; ts = TS(DataFrame(Index = dates, x1 = random(length(dates))));

julia&gt; lag(ts); 

julia&gt; ts = TS(DataFrame(Index = dates, x1 = random(length(dates))));

julia&gt; lag(ts, 2) # Lags by 2 values;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L795-L820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.lead" href="#TSx.lead"><code>TSx.lead</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Leading</strong></p><p><code>lead(ts::TS, lead_value::Int = 1)</code></p><p>Similar to lag, this method leads the <code>ts</code> object by <code>lead_value</code>. The lead rows are inserted with <code>missing</code>. Negative values of lead are also accepted (see <code>TSx.lag</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TSx, Dates, Random, Statistics, DataFrames; 

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; dates = collect(Date(2017,1,1):Day(1):Date(2018,3,10)); 

julia&gt; ts = TS(DataFrame(Index = dates, x1 = random(length(dates))));

julia&gt; lead(ts) # Leads once; 

julia&gt; ts = TS(DataFrame(Index = dates, x1 = random(length(dates))));

julia&gt; lead(ts, 2)# Leads by 2 values; 
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L827-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.log" href="#TSx.log"><code>TSx.log</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Log Function</strong></p><p><code>log(ts::TS, complex::Bool = false)</code></p><p>This method computes the log value of the non-index columns in the TS object.</p><p>If the <code>complex</code> argument is <code>true</code> the function returns the log of negative numbers as complex numbers.  But this also coerces the log of positive values as complex numbers with the imaginary component equal to 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L966-L978">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.ncol-Tuple{TS}" href="#TSx.ncol-Tuple{TS}"><code>TSx.ncol</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Size methods</strong></p><p><code>ncol(ts::TS)</code></p><p>Return the number of columns of <code>ts</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TSx, Random;

julia&gt; random(x) = rand(MersenneTwister(123), x);

julia&gt; TS([random(100) random(100) random(100)]) |&gt; TSx.ncol
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L598-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.nrow-Tuple{TS}" href="#TSx.nrow-Tuple{TS}"><code>TSx.nrow</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Size methods</strong></p><p><code>nrow(ts::TS)</code> Return the number of rows of <code>ts</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ts = TS(collect(1:100)) |&gt; TSx.nrow
100</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L582-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.plot" href="#TSx.plot"><code>TSx.plot</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Plottting</strong></p><p><code>plot(ts::TS, colnames::Vector{String} = TSx.names(ts))</code></p><p>Plots a timeseries plot of the TS object, with the X axis as the index. <code>colnames</code> lets you select which column you wish to plot.</p><p>This method uses the Plots package to implement this funcitonality.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TSx, DataFrames, Dates; 

julia&gt; df = DataFrame(Ind = Date(&quot;2022-02-01&quot;):Month(1):Date(&quot;2022-02-01&quot;)+Month(11), val1 = abs.(rand(Int16, 12)), val2 = abs.(rand(Int16, 12)));

julia&gt; TS(df);

julia&gt; # plot(ts); 
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L1070-L1090">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSx.rollapply-Tuple{Function, TS, Any, Int64}" href="#TSx.rollapply-Tuple{Function, TS, Any, Int64}"><code>TSx.rollapply</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Rolling Functions</strong></p><p><code>rollapply(fun::Function, ts::TS, column::Any, windowsize::Int)</code></p><p>Apply a function to a column of <code>ts</code> for each continuous set of rows of size <code>windowsize</code>. <code>column</code> could be any of the <code>DataFrame</code> column selectors.</p><p>The output is a TS object with <code>(nrow(ts) - windowsize + 1)</code> rows indexed with the last index value of each window.</p><p>This method uses <code>RollingFunctions</code> package to implement this functionality.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TSx, Dates; 

julia&gt; ts = TS(1:12, Date(&quot;2022-02-01&quot;):Month(1):Date(&quot;2022-02-01&quot;)+Month(11));  

julia&gt; ts |&gt; print
12×2 DataFrame
 Row │ Index       x1    
     │ Date        Int64 
─────┼───────────────────
   1 │ 2022-02-01      1
   2 │ 2022-03-01      2
   3 │ 2022-04-01      3
   4 │ 2022-05-01      4
   5 │ 2022-06-01      5
   6 │ 2022-07-01      6
   7 │ 2022-08-01      7
   8 │ 2022-09-01      8
   9 │ 2022-10-01      9
  10 │ 2022-11-01     10
  11 │ 2022-12-01     11
  12 │ 2023-01-01     12

Index: {Dates.Date} [12]
Size: (12, 1)

julia&gt; # rollapply(sum, ts, :x1, 10); 

julia&gt; # rollapply(Statistics.mean, ts, :x1, 5); 
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/xKDR/TSx.jl/blob/1d6a237c6393de41ebbc3dfc1aff72098384d40d/src/TSx.jl#L1001-L1049">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Sunday 17 April 2022 13:51">Sunday 17 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
