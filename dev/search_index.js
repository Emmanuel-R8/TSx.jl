var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TSx","category":"page"},{"location":"#TSx","page":"Home","title":"TSx","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TSx.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TSx]","category":"page"},{"location":"#TSx.JoinBoth","page":"Home","title":"TSx.JoinBoth","text":"Joins/Column-binding\n\nJoins/Column-binding\n\nTS objects can be combined together column-wise using Index as the column key. There are four kinds of column-binding operations possible as of now. Each join operation works by performing a Set operation on the Index column and then merging the datasets based on the output from the Set operation. Each operation changes column names in the final object automatically if the operation encounters duplicate column names amongst the TS objects.\n\nThe following join types are supported:\n\njoin(ts1::TS, ts2::TS, ::JoinBoth): a.k.a. inner join, takes the\n\nintersection of the indexes of ts1 and ts2, and then merges the columns of both the objects. The resulting object will only contain rows which are present in both the objects' indexes. The function will renamine the columns in the final object if they had same names in the TS objects.\n\njoin(ts1::TS, ts2::TS, ::JoinAll): a.k.a. outer join, takes the\n\nunion of the indexes of ts1 and ts2 before merging the other columns of input objects. The output will contain rows which are present in all the input objects while inserting missing values where a row was not present in any of the objects. This is the default behaviour if no JoinType object is provided.\n\njoin(ts1::TS, ts2::TS, ::JoinLeft): a.k.a. left join, takes the\n\nindex values which are present in the left object ts1 and finds matching index values in the right object ts2. The resulting object includes all the rows from the left object, the column values from the left object, and the values associated with matching index rows on the right. The operation inserts missing values where in the unmatched rows of the right object.\n\njoin(ts1::TS, ts2::TS, ::JoinRight): a.k.a. left join, is similar\n\nto left join but works in the opposite direction. The final object contains all the rows from the right object while inserting missing values in rows missing from the left object.\n\nThe default behaviour is to assume JoinAll() if no JoinType object is provided to the join method.\n\nExamples\n\njulia> df1 = DataFrame(Index=1:10, x1 = randn(10))\njulia> ts1 = TS(df1)\njulia> df2 = DataFrame(Index=1:10, x2 = randn(10))\njulia> ts2 = TS(df2)\n\njulia> join(ts1, ts2, JoinAll()) # with `missing` inserted\n# same as JoinAll()\njulia> join(ts1, ts2)            \njulia> join(ts1, ts2, JoinBoth())\njulia> join(ts1, ts2, JoinLeft())\njulia> join(ts1, ts2, JoinRight())\n\n# Using TimeType objects\njulia> dates = collect(Date(2017,1,1):Day(1):Date(2017,1,10))\njulia> ts1 = TS(DataFrame(Index = dates, x1 = randn(10)))\njulia> dates = collect(Date(2017,1,1):Day(1):Date(2017,1,30))\njulia> ts2 = TS(DataFrame(Index = dates, x1 = randn(30)))\n\njulia> join(ts1, ts2)\n\n\n\n\n\n","category":"type"},{"location":"#TSx.TS","page":"Home","title":"TSx.TS","text":"TS\n\nA type to hold ordered data with an index.\n\nA TS object is essentially a DataFrame with a specific column marked as an index and has the name Index. The DataFrame is sorted using index values during construction.\n\nConstructors\n\nTS(coredata::DataFrame, index::Union{String, Symbol, Int}=1)\nTS(coredata::DataFrame, index::AbstractVector{T}) where {T<:Int}\nTS(coredata::DataFrame, index::UnitRange{Int})\nTS(coredata::AbstractVector{T}, index::AbstractVector{V}) where {T, V}\nTS(coredata::AbstractVector{T}) where {T}\nTS(coredata::AbstractArray{T,2}, meta::Dict=Dict{String, Any}()) where {T}\n\nExamples\n\njulia> df = DataFrame(x1 = randn(10))\njulia> TS(df)\n\njulia> df = DataFrame(Index = [1, 2, 3], x1 = randn(3))\njulia> TS(df, 1)\n\njulia> dates = collect(Date(2017,1,1):Day(1):Date(2017,1,10))\njulia> df = DataFrame(dates = dates, x1 = randn(10))\njulia> TS(df, :dates)\njulia> TS(DataFrame(x1=randn(10), dates))\n\njulia> TS(randn(10))\njulia> TS(randn(10), dates)\n\n\n\n\n\n","category":"type"}]
}
